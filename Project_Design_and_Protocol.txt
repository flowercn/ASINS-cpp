# SINS-vTest 工程设计与通讯协议文档

**文档版本**: 1.0
**生成日期**: 2025-09-02

---

## 1. 工程设计总览 (Project Design Philosophy)

本工程的核心目标是实现对一个由64个ICM20602惯性测量单元（IMU）组成的传感器阵列进行同步、并行的超高速数据采集，并通过串口将数据实时传输至上位机。

为实现此目标，系统采用了以下关键设计思路：

### 1.1. 核心架构: 并行I2C总线

系统没有采用传统的I2C多路复用器芯片，而是通过软件实现了一种并行的I2C总线架构：

*   **共享时钟 (SCL)**: 所有64个传感器共享同一组SCL时钟信号线。当STM32驱动SCL线时，所有传感器会同步接收到时钟信号。
*   **独立数据 (SDA)**: 每个传感器都连接到STM32的一个独立GPIO引脚上，作为其专用的SDA数据线。
*   **并行通信**: 这种设计使得STM32可以同时向所有传感器广播指令（如设置要读取的寄存器地址），并在同一个SCL时钟周期内，同步地从64条独立的SDA线上读取或写入数据。这极大地提升了数据采集的吞吐量。

### 1.2. 性能优化

为了驱动这个复杂的并行总线并满足严苛的时序要求，I2C驱动 (`MyI2C.c`) 进行了深度的性能优化：

*   **直接寄存器操作**: 几乎所有的GPIO操作（设置高低电平、切换输入输出模式）都绕过了标准库函数 (`GPIO_Init`, `GPIO_WriteBit` 等)，转而直接对GPIO的 `BSRR`, `BRR`, `CRL`, `CRH` 等寄存器进行读写。这消除了函数调用的开销，是性能优化的基础。
*   **预计算端口掩码**: 在初始化阶段 (`I2C_Config`)，程序会遍历一次引脚定义数组，预先计算出每个GPIO端口上所有SDA/SCL引脚的整合“位掩码”（Bitmask）。在运行时，只需将这个掩码一次性写入端口寄存器，即可同步控制该端口上的所有引脚，避免了对引脚的逐个操作。
*   **循环展开与无分支逻辑**: 在性能最关键的 `I2C_ReceiveByte` 函数中，为了在一个I2C时钟周期内完成对64个SDA引脚的读取，代码采用了两种极限优化技巧：
    1.  **寄存器缓存**: 在循环的开始，一次性将所有相关GPIO端口的输入状态（`IDR`寄存器）读入局部变量，后续操作都基于这些高速的CPU寄存器变量，避免了64次对相对较慢的硬件寄存器的访问。
    2.  **循环展开与无分支操作**: 完全消除了 `for` 循环，并将 `if` 判断语句替换为纯粹的位运算 `(DATA[IDX] |= (-(!!((IDR) & (PIN)))) & (MASK))`。这消除了循环和分支跳转带来的CPU流水线开销，使得数据拼装过程的执行时间恒定且达到理论最快。

### 1.3. 数据流与传输

*   **DMA传输**: 串口发送完全由DMA（直接内存访问）控制器负责，CPU在准备好数据后只需启动DMA即可，无需等待发送完成，极大地解放了CPU资源。
*   **乒乓缓冲 (Ping-Pong Buffer)**: 系统使用两个缓冲区（Ping和Pong）来实现数据的无缝传输。CPU总是在其中一个空闲的缓冲区中填充新的传感器数据，而DMA则在同时发送另一个已填满的缓冲区。这种机制确保了数据流不会因为等待串口发送而中断。

---

## 2. 串口通讯协议 (Serial Communication Protocol)

数据通过串口以数据帧的形式连续发送。一个完整的数据帧由 **8个数据包** 组成。

### 2.1. 单个数据包结构

每个数据包大小为67字节，结构如下：

| 字段         | 长度 (Bytes) | 值/描述                                    |
|--------------|--------------|--------------------------------------------|
| **帧头**     | 2            | 固定为 `0xA5 0x5A`                         |
| **包序号**   | 1            | `0x01` 到 `0x08`，用于标识包内容          |
| **数据负载** | 64           | 来自64个传感器的数据，每个传感器占1字节    |

### 2.2. 数据包内容映射

根据“包序号”，数据负载区的64个字节有不同的含义。其中，`ucData[i]` 代表来自第 `i` 个传感器的数据 (i = 0 to 63)。

*   **包 0x01**: `ucData[i]` = 传感器i的 **X轴加速度 低8位** (`ACCEL_XOUT_L`)
*   **包 0x02**: `ucData[i]` = 传感器i的 **Y轴加速度 低8位** (`ACCEL_YOUT_L`)
*   **包 0x03**: `ucData[i]` = 传感器i的 **Z轴加速度 高8位** (`ACCEL_ZOUT_H`)
*   **包 0x04**: `ucData[i]` = 传感器i的 **Z轴加速度 低8位** (`ACCEL_ZOUT_L`)
*   **包 0x05**: `ucData[i]` = 传感器i的 **X轴陀螺仪 低8位** (`GYRO_XOUT_L`)
*   **包 0x06**: `ucData[i]` = 传感器i的 **Y轴陀螺仪 低8位** (`GYRO_YOUT_L`)
*   **包 0x07**: `ucData[i]` = 传感器i的 **Z轴陀螺仪 低8位** (`GYRO_ZOUT_L`)

### 2.3. 元数据包 (包 0x08) 解析

这是一个特殊的数据包，它不直接包含传感器读数，而是包含了为节省带宽而压缩的**符号位**、**错误状态**和**CRC校验码**。

*   **`ucData[0-39]` (40字节)**: **符号位图**。
    *   这40个字节被分为5组，每组8个字节（64位），分别对应 `AX_H`, `AY_H`, `GX_H`, `GY_H`, `GZ_H` 这5个未被直接传输的高位字节。
    *   例如，要检查传感器 `k` 的 `AX_H` 是否为负，可以检查 `ucData[k/8]` 的第 `k%8` 位是否为1。

*   **`ucData[40-47]` (8字节)**: **错误状态位图**。
    *   这是一个64位的位图。如果传感器 `k` 对应位为1，表示该传感器的高位字节读数既不是 `0x00` 也不是 `0xFF`，被视为一种异常状态。

*   **`ucData[48]` (1字节)**: **CRC-8校验和**。
    *   这是对前7个数据包的 `ucData` 区域（`7 * 64 = 448` 字节）进行CRC-8/MAXIM计算后得到的结果。

*   **`ucData[49-63]`**: 预留，当前为0。
